None:None: ëÅç 84444451
 3d8f98c39 Re-implement macro to constexpr transition
 ? no file 'None' in 3d8f98c395237982b12f6dbefa70925def637567~..3d8f98c395237982b12f6dbefa70925def637567
	[ridiculousfish] @mqudsi there's several C++ landmines in changes like this:

		1. Using an array like `wchar_t FISH_BIN_DIR[]` instead of a `#define` or a `const wchar_t * const` causes the compiler to allocate a symbol for the array. This makes the resulting executable slightly bigger (2k in my test), slows down linking, etc. The effect is not large but there's no reason to incur it; it should be a `const wchar_t * const`.

		2. All of the variables changed in .cpp files should be marked `static`. static here does not refer to an allocation startegy, but rather to visibility to other object files. Please restore the statics.

		3. I'm nervous about putting constexpr variables in .h files because of the ODR rule: they need a single definition if they are ODR-used, and compilers can *disagree* on whether a variable is ODR-used. We risk mysterious build errors by doing this. More on [constexpr ODR-used](https://stackoverflow.com/questions/17139005/constexpr-and-odr). The advantage of `#define` is that it dodges this issue entirely. (An alternative to `#define` is `enum` at least for ints). [More on constexpr variables in headers](https://stackoverflow.com/questions/50488831/use-of-constexpr-in-header-file).

		Anyways if you want to keep this change my requests are:

		1. Strings should be pointers, not arrays.
		2. Every variable in a .cpp file should be static, unless it really is directly referenced from other files.
		3. No constexpr variables in headers, unless we also provide a definition in a single file. May not be worth it - ints can become enums, strings can remain defines.
	[ridiculousfish] I ended up reverting this in 5f4583b52da44cb82b5f81fced6c2d74730c4d2d as it also broke the centos 7 build.
	[mqudsi] Thanks for the feedback, @ridiculousfish.

		* I completely forgot that the compiled binary representation (and not just the compile-time type info) of a `wchar_t[]` differs from that of `* wchar_t`. I originally had the strings declared as `const wchar_t * XXX` but that breaks `const_strlen()` (which expects either a literal or an array). There were only a couple of variables that used (or were upgraded to use) `const_strlen()`, but not taking into account the cost of the change to an array, I changed all the constant strings to arrays. This wasn't and wouldn't be an issue with `#define` instead, as the literal string would be passed to `const_strlen()` in that case.
		* I considered but dismissed the usages of constexpr for value types as being clear cases of `!odr-used` (do you think even that wasn't a safe assumption? the SO link seems to back that view, especially per n1337) but when I was mass replacing matching strings I ended up changing some in header files as well. *mea culpa* there, as I think we definitely can't rule out odr-used for those (regardless of pointer or array).
		* *Assuming* not odr-used, `static` should (would?) make no difference since these would be constant variables with no linkage, meaning there's nothing there for other compilation units to find, no? I believe all the statics that I changed were value types, again assumed to have no linkage.

		TBH, there's no real benefit to any of this aside from cleanup. I'm not attached to this change at all and I'd probably just revert it.
	[mqudsi] Oh, there you go. üëç
	[ridiculousfish] ODR-uses of constexpr variables is IME one of those things that doesn't always follow the standard. No way to learn this except the hard way :(
	[mqudsi] That‚Äôs the nice thing about C++ - you learn something new every time you write in it üòÖ

		thanks for the insights and sorry for shooting us/myself with these loaded footguns.

ëÅç
