use std::{
    collections::{HashMap, HashSet},
    fs::File,
    io::Read,
    path::Path,
    process::Command,
};

use fish_build_helper::workspace_root;

use fluent::{FluentBundle, FluentResource};
use unic_langid::LanguageIdentifier;

fn main() {
    let unique_ids = extract_fluent_ids();

    let ftl_dir = workspace_root().join("localization").join("fluent");
    // These must have translations for every message.
    let required_langs = [fish_fluent::FALLBACK_LANGUAGE];
    let fluent_resources = parse_ftl_files(&ftl_dir);
    check_for_extra_ids(&fluent_resources, &unique_ids);
    check_for_unsorted_ids(&fluent_resources, &unique_ids);
    let fluent_bundles = resources_to_bundles(fluent_resources);
    check_required_langs(&fluent_bundles, &required_langs, &unique_ids);
}

fn resources_to_bundles(
    resources: HashMap<String, FluentResource>,
) -> HashMap<String, FluentBundle<FluentResource>> {
    let mut bundles = HashMap::new();
    for (language, resource) in resources {
        let langid: LanguageIdentifier = language
            .parse()
            .map_err(|e| format!("Failed to parse language identifier {language}: {e}"))
            .unwrap();
        let mut bundle = FluentBundle::new(vec![langid]);
        bundle
            .add_resource(resource)
            .map_err(|e| {
                format!("Failed to add FTL resources to the bundle for language {language}: {e:?}")
            })
            .unwrap();
        bundles.insert(language, bundle);
    }
    bundles
}

fn extract_fluent_ids() -> HashSet<String> {
    let mut tempfile = fish_tempfile::new_file().unwrap();
    Command::new(env!("CARGO"))
        .args([
            "check",
            "--features=fluent-extract",
            "--workspace",
            "--all-targets",
        ])
        .env("FISH_FLUENT_ID_FILE", tempfile.path().as_os_str())
        .status()
        .map_err(|e| format!("Failed to extract Fluent IDs: {e}"))
        .unwrap();
    let mut id_file_content = String::new();
    tempfile
        .get_mut()
        .read_to_string(&mut id_file_content)
        .unwrap();
    HashSet::from_iter(id_file_content.lines().map(|line| line.to_string()))
}

fn parse_ftl_files(ftl_dir: &Path) -> HashMap<String, FluentResource> {
    let mut bundles = HashMap::new();
    for dir_entry in ftl_dir.read_dir().unwrap() {
        let dir_entry = dir_entry.unwrap();
        let file_name = dir_entry.file_name().into_string().unwrap();
        let Some(language) = file_name.strip_suffix(".ftl") else {
            continue;
        };
        let mut file_content = String::new();
        File::open(dir_entry.path())
            .unwrap()
            .read_to_string(&mut file_content)
            .unwrap();
        match FluentResource::try_new(file_content.clone()) {
            Ok(resource) => {
                bundles.insert(language.to_owned(), resource);
            }
            Err((_resource, errors)) => {
                let mut error_string = format!("Errors parsing FTL file for {language}:\n");
                for error in errors {
                    error_string.push_str(&format!("{error}\n"));
                }
                panic!("{error_string}");
            }
        }
    }
    bundles
}

fn show_per_language_id_errors(header: &str, ids_per_language: HashMap<&str, Vec<&str>>) {
    let mut error_message = String::new();
    error_message.push_str(header);
    error_message.push_str(":\n\n");
    for (language, ids) in ids_per_language {
        error_message.push_str("For language ");
        error_message.push_str(language);
        error_message.push_str(":\n");
        for id in ids {
            error_message.push_str(id);
            error_message.push('\n');
        }
    }
    panic!("{error_message}");
}

fn check_required_langs(
    ftl_data: &HashMap<String, FluentBundle<FluentResource>>,
    required_langs: &[&str],
    required_ids: &HashSet<String>,
) {
    let mut missing_ids_per_language = HashMap::new();
    for &language in required_langs {
        let Some(bundle) = ftl_data.get(language) else {
            panic!("Expected FTL file for language {language} but did not find it.");
        };
        let mut missing_ids_for_language = vec![];
        for id in required_ids {
            if !bundle.has_message(id) {
                missing_ids_for_language.push(id.as_str());
            }
        }
        if !missing_ids_for_language.is_empty() {
            // Show missing IDs in alphabetical order
            missing_ids_for_language.sort();
            missing_ids_per_language.insert(language, missing_ids_for_language);
        }
    }
    if !missing_ids_per_language.is_empty() {
        show_per_language_id_errors("Missing IDs", missing_ids_per_language);
    }
}

fn check_for_extra_ids(ftl_data: &HashMap<String, FluentResource>, valid_ids: &HashSet<String>) {
    let mut unexpected_ids_per_language = HashMap::new();
    for (language, resource) in ftl_data {
        let mut unexpected_ids_for_language = vec![];
        for entry in resource.entries() {
            if let fluent_syntax::ast::Entry::Message(message) = entry {
                let id = message.id.name;
                if !valid_ids.contains(id) {
                    unexpected_ids_for_language.push(id);
                }
            }
        }
        if !unexpected_ids_for_language.is_empty() {
            unexpected_ids_per_language.insert(language.as_str(), unexpected_ids_for_language);
        }
    }
    if !unexpected_ids_per_language.is_empty() {
        show_per_language_id_errors("Unexpected IDs found", unexpected_ids_per_language);
    }
}

/// Call this after establishing that no invalid IDs appear.
fn check_for_unsorted_ids(
    fluent_resources: &HashMap<String, FluentResource>,
    valid_ids: &HashSet<String>,
) {
    let mut sorted_ids = valid_ids.iter().collect::<Vec<_>>();
    sorted_ids.sort();
    let sorted_ids = sorted_ids;
    for (language, resource) in fluent_resources {
        let mut sorted_id_index = 0;
        for entry in resource.entries() {
            if let fluent_syntax::ast::Entry::Message(message) = entry {
                let id = message.id.name;
                while *(sorted_ids[sorted_id_index].as_str()) < *id
                    && sorted_id_index < sorted_ids.len() - 1
                {
                    sorted_id_index += 1;
                }
                if *sorted_ids[sorted_id_index] != *id {
                    let mut error_string = String::from("Expected ID order:\n\n");
                    for fluent_id in sorted_ids {
                        error_string.push_str(&format!("{fluent_id}\n"));
                    }
                    error_string.push_str(&format!("\nFTL file for language {language} is not sorted properly. ID '{id}' appears out of order. See the full expected ID order above."));
                    panic!("{error_string}");
                }
            }
        }
    }
}
